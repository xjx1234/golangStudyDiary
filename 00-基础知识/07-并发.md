## 并发

有人把Go语言比作 21 世纪的C语言，第一是因为Go语言设计简单，第二则是因为 21 世纪最重要的就是并发程序设计，而 Go 从语言层面就支持并发。同时实现了自动垃圾回收机制。

下面来介绍几个概念：

**并发/并行**

并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。

![](https://raw.githubusercontent.com/xjx1234/golangStudyDiary/master/00-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/parallel.png)



并发(concurrency)在微观上，是指在同一时刻只能有一条指令执行，但多个程序指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个程序快速交替的执行。并发的本质是利用cpu时间片轮转，使多个进程快速交替的执行。

![](https://raw.githubusercontent.com/xjx1234/golangStudyDiary/master/00-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/concurrency.png)



以咖啡机的例子来解释并行和并发的区别：

![]()![cofe](https://raw.githubusercontent.com/xjx1234/golangStudyDiary/master/00-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/cofe.png)

总结的说：

- 并行是两个队列同时使用两台咖啡机 （真正的多任务）
- 并发是两个队列交替使用一台咖啡机 （ 假 的多任务）

**进程/线程/协程**

​	进程：独立地址空间，拥有PCB

​	线程：有独立的PCB，但没有独立的地址空间(共享)

​	区别：在于是否共享地址空间。独居(进程)；合租(线程)。

​	线程：最小的执行单位

​	进程：最小分配资源单位，可看成是只有一个线程的进程。

​    协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。

### Go协程（Goroutine)

Go协程（Goroutine）是与其他[函数](http://blog.csdn.net/u011304970/article/details/74885661)或[方法](http://blog.csdn.net/u011304970/article/details/75042912)同时运行的函数或方法。可以认为Go协程是轻量级的线程。与创建线程相比，创建Go协程的成本很小。因此在Go中同时运行上千个协程是很常见的。

**协程对比线程优点**

- 与线程相比，Go协程的开销非常小。Go协程的堆栈大小只有几kb，它可以根据应用程序的需要而增长和缩小，而线程必须指定堆栈的大小，并且堆栈的大小是固定的。
- Go协程被多路复用到较少的OS线程。在一个程序中数千个Go协程可能只运行在一个线程中。如果该线程中的任何一个Go协程阻塞（比如等待用户输入），那么Go会创建一个新的OS线程并将其余的Go协程移动到这个新的OS线程。所有这些操作都是 runtime 来完成的，而我们程序员不必关心这些复杂的细节，只需要利用 Go 提供的简洁的 API 来处理并发就可以了。
- Go 协程之间通过信道（channel）进行通信。信道可以防止多个协程访问共享内存时发生竟险（race condition）。信道可以想象成多个协程之间通信的管道。我们将在下一篇教程中介绍信道

使用 go 关键字就可以创建 goroutine，将 go 声明放到一个需调用的函数之前，在相同地址空间调用运行这个函数，这样该函数执行时便会作为一个独立的并发线程，这种线程在Go语言中则被称为 goroutine。用法如下:

```go

```

