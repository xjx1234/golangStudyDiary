## 并发

有人把Go语言比作 21 世纪的C语言，第一是因为Go语言设计简单，第二则是因为 21 世纪最重要的就是并发程序设计，而 Go 从语言层面就支持并发。同时实现了自动垃圾回收机制。

下面来介绍几个概念：

**并发/并行**

并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/parallel.png)



并发(concurrency)在微观上，是指在同一时刻只能有一条指令执行，但多个程序指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个程序快速交替的执行。并发的本质是利用cpu时间片轮转，使多个进程快速交替的执行。

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/concurrency.png)



以咖啡机的例子来解释并行和并发的区别：

![cofe](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/cofe.png)

总结的说：

- 并行是两个队列同时使用两台咖啡机 （真正的多任务）
- 并发是两个队列交替使用一台咖啡机 （ 假 的多任务）

**进程/线程/协程**

​	进程：独立地址空间，拥有PCB

​	线程：有独立的PCB，但没有独立的地址空间(共享)

​	区别：在于是否共享地址空间。独居(进程)；合租(线程)。

​	线程：最小的执行单位

​	进程：最小分配资源单位，可看成是只有一个线程的进程。

​    协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。

### Go协程（Goroutine)

Go协程（Goroutine）是与其他[函数](http://blog.csdn.net/u011304970/article/details/74885661)或[方法](http://blog.csdn.net/u011304970/article/details/75042912)同时运行的函数或方法。可以认为Go协程是轻量级的线程。与创建线程相比，创建Go协程的成本很小。因此在Go中同时运行上千个协程是很常见的。

**协程对比线程优点**

- 与线程相比，Go协程的开销非常小。Go协程的堆栈大小只有几kb，它可以根据应用程序的需要而增长和缩小，而线程必须指定堆栈的大小，并且堆栈的大小是固定的。
- Go协程被多路复用到较少的OS线程。在一个程序中数千个Go协程可能只运行在一个线程中。如果该线程中的任何一个Go协程阻塞（比如等待用户输入），那么Go会创建一个新的OS线程并将其余的Go协程移动到这个新的OS线程。所有这些操作都是 runtime 来完成的，而我们程序员不必关心这些复杂的细节，只需要利用 Go 提供的简洁的 API 来处理并发就可以了。
- Go 协程之间通过信道（channel）进行通信。信道可以防止多个协程访问共享内存时发生竟险（race condition）。信道可以想象成多个协程之间通信的管道。我们将在下一篇教程中介绍信道

使用 go 关键字就可以创建 goroutine，将 go 声明放到一个需调用的函数之前，在相同地址空间调用运行这个函数，这样该函数执行时便会作为一个独立的并发线程，这种线程在Go语言中则被称为 goroutine。用法如下:

```go
package main

import "fmt"

func hello() {
	fmt.Println("hello goroutine")
}

func main() {
	go hello() // 开启协程调用hello函数
	//开启协程 调用匿名函数
	go func(name string) {
		fmt.Println("hello " + name + " goroutine")
	}("anonymous")
	fmt.Println("main function")
}
```

从上述例子中，我们可以总结出，创建普通协程和匿名的格式为：

> go 函数名( 参数列表 )

匿名协程：

> go func( 参数列表 ){
>   函数体
> }( 调用参数列表 )

当你运行这个程序时候，你会发现，运行结果为: `main function` ,为什么跟我们预想的不一致呢？ 这时候，我们需要了解下go协程的两个属性：

- **当创建一个Go协程时，创建这个Go协程的语句立即返回。与函数不同，程序流程不会等待Go协程结束再继续执行。程序流程在开启Go协程后立即返回并开始执行下一行代码，忽略Go协程的任何返回值。**
- **在主协程存在时才能运行其他协程，主协程终止则程序终止，其他协程也将终止。**

我想你已经知道了为什么我们的协程为什么没有运行。在11行调用 `go hello()`后，程序的流程直接调转到下一条语句执行，并没有等待 `hello` 协程退出，然后打印 `main function`。接着主协程结束运行，不会再执行任何代码，因此 `hello` 协程没有得到运行的机会。我们可以在main函数最后加上一句 `time.Sleep(1)`，程序运行结果为:

 `hello goroutine
main function
hello anonymous goroutine`

### 通道 (Channel)

Channel可以被认为是协程之间通信的管道。与水流从管道的一端流向另一端一样，数据可以从信道的一端发送并在另一端接收。Go语言提倡使用通信的方法代替共享内存，当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。这里通信的方法就是使用通道（channel），如下图所示:

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/channel.jpg)

#### 声明通道类型

通道声明格式如下:

> var 通道变量 chan 通道类型

chan 类型的空值是 nil，声明后需要配合 make 后才能使用。

#### 创建通道

通道是引用类型，需要使用 make 进行创建，格式如下：

> 通道实例 := make(chan 数据类型)

声明与创建通道的实际用法，我们通过下面例子熟悉：

```go
	var ch1 chan int //声明通道
	ch1 = make(chan int) //创建通道
	cha2 := make(chan interface{}) //声明并创建通道
	fmt.Printf("%v, %v", ch1, cha2)
```

#### 通过通道发送接收数据

1.  通道发送数据

   通道的发送使用特殊的操作符`<-`，将数据通过通道发送的格式为：

   > 通道变量 <- 值

   

2.  通道接收数据

   通道接收同样使用`<-`操作符，通道接收有如下特性：

- 通道的收发操作在不同的两个 goroutine 间进行。

- 接收将持续阻塞直到发送方发送数据。

- 每次接收一个元素。

  

  通道的数据接收有如下写法：

> data := <-ch   //阻塞接收数据

> data, ok := <-ch //非堵塞接收数据

> <-ch // 接收任意数据，忽略接收的数据

> ​	for data := range ch { } // 循环接收

下面我们通过一个例子来说明通道的使用:

```go
func hello2(ch chan bool) {
	ch <- true
	fmt.Println("hello ch")
}
func main(){
    ch := make(chan bool)
	go hello2(ch)
	<-ch
	fmt.Println("run end")
}
```

上面程序定义了一个 bool 类型的通道 `ch` ，然后将它作为参数传输给 `hello2` 函数，然后通道 `ch` 一直在被堵塞到其他程序向通道写数据为止。本程序执行结果为：

> hello ch
> run end

我们再写一个例子，来帮助与理解通道。该程序打印一个数组的平方和立方和，平方和立方结果分别写入一个通道，最后将通道值相加，代码如下：

```go
func calSquares(num int, sumData chan int) {
	result := num * num
	sumData <- result
}

func calCubes(num int, sumData chan int) {
	result := num * num * num
	sumData <- result
}

func main(){
	squaresChan := make(chan int)
	cubesChan := make(chan int)
	go calSquares(2, squaresChan)
	go calCubes(3, cubesChan)
	s1, s2 := <-squaresChan, <-cubesChan
	fmt.Printf("the sum is %d\n", s1+s2)
}
```

这两个函数接受不同的信道作为参数，并分别运行在各自的协程中, 最后将结果写入各自的信道。主协程在同时等待这两个信道中的数据。一旦从这两个信道中接收到数据，它们分别被存放在变量 `s1` 和 `s2` 中，最后将它们的和打印出来。程序的输出为：

> the sum is 31

#### 单向通道 - 通道中的单行道

Go语言的类型系统提供了单方向的 channel 类型，顾名思义，单向 channel 只能用于发送或者接收数据。channel 本身必然是同时支持读写的，否则根本没法用。假如一个 channel 真的只能读，那么肯定只会是空的，因为你没机会往里面写数据。同理，如果一个 channel 只允许写，即使写进去了，也没有丝毫意义，因为没有机会读取里面的数据。所谓的单向 channel 概念，其实只是对 channel 的一种使用限制。

单项通道声明格式如下：

> var 通道实例 chan<- 元素类型   // 只能发送通道

> var 通道实例 <-chan 元素类型   // 只能接收通道

下面给出单项通道的使用例子：

```go
	sendOnlyChan := make(chan<- int) // 只能发送通道
	recOnlyChan := make(<-chan int) //只能接收通道
	sendOnlyChan <- 1
	<-sendOnlyChan
```

这个程序代码段，运行起来是报错的，这是非法的，程序将无法通过编译，程序会报错为：`invalid operation: <-sendOnlyChan (receive from send-only type chan<- int)`，但是如果一个通道只能读或者写，创建一个只写通道有什么用呢？**这就是信道转型的用途。可以将双向信道转换为只写或只读信道，但是反过来却不行。**，效果如下例子：

```go
package main

import "fmt"

func sendData(sendch chan<- int) {  
    sendch <- 10
}

func main() {  
    chnl := make(chan int)
    go sendData(chnl)
    fmt.Println(<-chnl)
}
```

#### 关闭通道

关闭 channel 非常简单，直接使用 Go语言内置的 close() 函数即可：

> close(ch)

在介绍了如何关闭 channel 之后，我们就多了一个问题：如何判断一个 channel 是否已经被关闭？我们可以在读取的时候使用多重返回值的方式：

> x, ok := <-ch

这个用法与 map 中的按键获取 value 的过程比较类似，只需要看第二个 bool 返回值即可，如果返回值是 false 则表示 ch 已经被关闭。

#### 无缓冲与有缓冲通道

Go语言中无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。阻塞指的是由于某种原因数据没有到达，当前协程（线程）持续处于等待状态，直到条件满足才解除阻塞。

下图展示两个 goroutine 如何利用无缓冲的通道来共享一个值：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/unbuffered_channel.jpg)

在第 1 步，两个 goroutine 都到达通道，但哪个都没有开始执行发送或者接收。
 在第 2 步，左侧的 goroutine 将它的手伸进了通道，这模拟了向通道发送数据的行为。这时，这个 goroutine 会在通道中被锁住，直到交换完成。
 在第 3 步，右侧的 goroutine 将它的手放入通道，这模拟了从通道里接收数据。这个 goroutine 一样也会在通道中被锁住，直到交换完成。
 在第 4 步和第 5 步，进行交换，并最终，在第 6 步，两个 goroutine 都将它们的手从通道里拿出来，这模拟了被锁住的 goroutine 得到释放。两个 goroutine 现在都可以去做别的事情了。

无缓冲channel创建格式:

> 通道实例 := make(chan 数据类型)

示例代码:

```go
func main() {
	unbufferedChan := make(chan int) //创建无缓存通道
	fmt.Printf("leb(c)=%d, cap(c)=%d\n", len(unbufferedChan), cap(unbufferedChan))
	go func() {
		defer fmt.Println("子协程结束")
		for i := 0; i < 3; i++ {
			fmt.Println("here", i)
			unbufferedChan <- i
			fmt.Printf("子进程正在运行[%d]: len(c)=%d,cap(c)=%d \n", i, len(unbufferedChan), cap(unbufferedChan))
		}
	}()
	
	for i := 0; i < 3; i++ {
		num := <-unbufferedChan
		fmt.Println("num=", num)
	}

	fmt.Println("main主程序结束")
}
```

我们先看一下运行结果再来看代码： 

```go
leb(c)=0, cap(c)=0
here 0
子进程正在运行[0]: len(c)=0,cap(c)=0
here 1
num= 0
num= 1
子进程正在运行[1]: len(c)=0,cap(c)=0
here 2
子进程正在运行[2]: len(c)=0,cap(c)=0
子协程结束
num= 2
main主程序结束

```

Go语言中有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。示例图如下：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/buffered_channel.jpg)

如何创建带缓冲的通道呢？参见如下格式：

> 通道实例 := make(chan 通道类型, 缓冲大小)

下面通过一个例子中来理解带缓冲通道的用法，参见下面的代码：

```go
func main(){
    bufferedChan := make(chan int, 3)
	fmt.Printf("len(c)=%d,cap(c)=%d\n", len(bufferedChan), cap(bufferedChan))
	go func() {
		defer fmt.Println("子协程结束")
		for i := 0; i < 3; i++ {
			bufferedChan <- i
			fmt.Printf("子协程正在运行[%d]: len(c)=%d, cap(c)=%d\n", i, len(bufferedChan), cap(bufferedChan))
		}
	}()
	for i := 0; i < 3; i++ {
		num := <-bufferedChan
		fmt.Println("num=", num)
	}
	fmt.Println("main主程序结束")
}
```

我们先看一下运行结果：

```go
len(c)=0,cap(c)=3
子协程正在运行[0]: len(c)=0, cap(c)=3
子协程正在运行[1]: len(c)=1, cap(c)=3
子协程正在运行[2]: len(c)=2, cap(c)=3
子协程结束
num= 0
num= 1
num= 2
main主程序结束
```

带缓冲通道在很多特性上和无缓冲通道是类似的。无缓冲通道可以看作是长度永远为 0 的带缓冲通道。因此根据这个特性，带缓冲通道在下面列举的情况下依然会发生阻塞：

- 带缓冲通道被填满时，尝试再次发送数据时发生阻塞。
- 带缓冲通道为空时，尝试接收数据时发生阻塞。

**为什么Go语言对通道要限制长度而不提供无限长度的通道？**

我们知道通道（channel）是在两个 goroutine 间通信的桥梁。使用 goroutine 的代码必然有一方提供数据，一方消费数据。当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。

#### Channel(通道)超时机制以及多路复用

