## 并发

有人把Go语言比作 21 世纪的C语言，第一是因为Go语言设计简单，第二则是因为 21 世纪最重要的就是并发程序设计，而 Go 从语言层面就支持并发。同时实现了自动垃圾回收机制。

下面来介绍几个概念：

**并发/并行**

并行(parallel)：指在同一时刻，有多条指令在o多个处理器上同时执行。

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/parallel.png)



并发(concurrency)在微观上，是指在同一时刻只能有一条指令执行，但多个程序指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个程序快速交替的执行。并发的本质是利用cpu时间片轮转，使多个进程快速交替的执行。

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/concurrency.png)



以咖啡机的例子来解释并行和并发的区别：

![cofe](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/cofe.png)

总结的说：

- 并行是两个队列同时使用两台咖啡机 （真正的多任务）
- 并发是两个队列交替使用一台咖啡机 （ 假 的多任务）

**进程/线程/协程**

​	进程：独立地址空间，拥有PCB

​	线程：有独立的PCB，但没有独立的地址空间(共享)

​	区别：在于是否共享地址空间。独居(进程)；合租(线程)。

​	线程：最小的执行单位

​	进程：最小分配资源单位，可看成是只有一个线程的进程。

​    协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。

### Go协程（Goroutine)

Go协程（Goroutine）是与其他[函数](http://blog.csdn.net/u011304970/article/details/74885661)或[方法](http://blog.csdn.net/u011304970/article/details/75042912)同时运行的函数或方法。可以认为Go协程是轻量级的线程。与创建线程相比，创建Go协程的成本很小。因此在Go中同时运行上千个协程是很常见的。

**协程对比线程优点**

- 与线程相比，Go协程的开销非常小。Go协程的堆栈大小只有几kb，它可以根据应用程序的需要而增长和缩小，而线程必须指定堆栈的大小，并且堆栈的大小是固定的。
- Go协程被多路复用到较少的OS线程。在一个程序中数千个Go协程可能只运行在一个线程中。如果该线程中的任何一个Go协程阻塞（比如等待用户输入），那么Go会创建一个新的OS线程并将其余的Go协程移动到这个新的OS线程。所有这些操作都是 runtime 来完成的，而我们程序员不必关心这些复杂的细节，只需要利用 Go 提供的简洁的 API 来处理并发就可以了。
- Go 协程之间通过信道（channel）进行通信。信道可以防止多个协程访问共享内存时发生竟险（race condition）。信道可以想象成多个协程之间通信的管道。我们将在下一篇教程中介绍信道

使用 go 关键字就可以创建 goroutine，将 go 声明放到一个需调用的函数之前，在相同地址空间调用运行这个函数，这样该函数执行时便会作为一个独立的并发线程，这种线程在Go语言中则被称为 goroutine。用法如下:

```go
package main

import "fmt"

func hello() {
	fmt.Println("hello goroutine")
}

func main() {
	go hello() // 开启协程调用hello函数
	//开启协程 调用匿名函数
	go func(name string) {
		fmt.Println("hello " + name + " goroutine")
	}("anonymous")
	fmt.Println("main function")
}
```

从上述例子中，我们可以总结出，创建普通协程和匿名的格式为：

> go 函数名( 参数列表 )

匿名协程：

> go func( 参数列表 ){
>   函数体
> }( 调用参数列表 )

当你运行这个程序时候，你会发现，运行结果为: `main function` ,为什么跟我们预想的不一致呢？ 这时候，我们需要了解下go协程的两个属性：

- **当创建一个Go协程时，创建这个Go协程的语句立即返回。与函数不同，程序流程不会等待Go协程结束再继续执行。程序流程在开启Go协程后立即返回并开始执行下一行代码，忽略Go协程的任何返回值。**
- **在主协程存在时才能运行其他协程，主协程终止则程序终止，其他协程也将终止。**

我想你已经知道了为什么我们的协程为什么没有运行。在11行调用 `go hello()`后，程序的流程直接调转到下一条语句执行，并没有等待 `hello` 协程退出，然后打印 `main function`。接着主协程结束运行，不会再执行任何代码，因此 `hello` 协程没有得到运行的机会。我们可以在main函数最后加上一句 `time.Sleep(1)`，程序运行结果为:

 `hello goroutine
main function
hello anonymous goroutine`

### 通道 (Channel)

Channel可以被认为是协程之间通信的管道。与水流从管道的一端流向另一端一样，数据可以从信道的一端发送并在另一端接收。Go语言提倡使用通信的方法代替共享内存，当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。这里通信的方法就是使用通道（channel），如下图所示:

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/channel.jpg)

#### 声明通道类型

通道声明格式如下:

> var 通道变量 chan 通道类型

chan 类型的空值是 nil，声明后需要配合 make 后才能使用。

#### 创建通道

通道是引用类型，需要使用 make 进行创建，格式如下：

> 通道实例 := make(chan 数据类型)

声明与创建通道的实际用法，我们通过下面例子熟悉：

```go
	var ch1 chan int //声明通道
	ch1 = make(chan int) //创建通道
	cha2 := make(chan interface{}) //声明并创建通道
	fmt.Printf("%v, %v", ch1, cha2)
```

#### 通过通道发送接收数据

1.  通道发送数据

   通道的发送使用特殊的操作符`<-`，将数据通过通道发送的格式为：

   > 通道变量 <- 值

   

2.  通道接收数据

   通道接收同样使用`<-`操作符，通道接收有如下特性：

- 通道的收发操作在不同的两个 goroutine 间进行。

- 接收将持续阻塞直到发送方发送数据。

- 每次接收一个元素。

  

  通道的数据接收有如下写法：

> data := <-ch   //阻塞接收数据

> data, ok := <-ch //非堵塞接收数据

> <-ch // 接收任意数据，忽略接收的数据

> ​	for data := range ch { } // 循环接收

下面我们通过一个例子来说明通道的使用:

```go
func hello2(ch chan bool) {
	ch <- true
	fmt.Println("hello ch")
}
func main(){
    ch := make(chan bool)
	go hello2(ch)
	<-ch
	fmt.Println("run end")
}
```

上面程序定义了一个 bool 类型的通道 `ch` ，然后将它作为参数传输给 `hello2` 函数，然后通道 `ch` 一直在被堵塞到其他程序向通道写数据为止。本程序执行结果为：

> hello ch
> run end

我们再写一个例子，来帮助与理解通道。该程序打印一个数组的平方和立方和，平方和立方结果分别写入一个通道，最后将通道值相加，代码如下：

```go
func calSquares(num int, sumData chan int) {
	result := num * num
	sumData <- result
}

func calCubes(num int, sumData chan int) {
	result := num * num * num
	sumData <- result
}

func main(){
	squaresChan := make(chan int)
	cubesChan := make(chan int)
	go calSquares(2, squaresChan)
	go calCubes(3, cubesChan)
	s1, s2 := <-squaresChan, <-cubesChan
	fmt.Printf("the sum is %d\n", s1+s2)
}
```

这两个函数接受不同的信道作为参数，并分别运行在各自的协程中, 最后将结果写入各自的信道。主协程在同时等待这两个信道中的数据。一旦从这两个信道中接收到数据，它们分别被存放在变量 `s1` 和 `s2` 中，最后将它们的和打印出来。程序的输出为：

> the sum is 31

#### 单向通道 - 通道中的单行道

Go语言的类型系统提供了单方向的 channel 类型，顾名思义，单向 channel 只能用于发送或者接收数据。channel 本身必然是同时支持读写的，否则根本没法用。假如一个 channel 真的只能读，那么肯定只会是空的，因为你没机会往里面写数据。同理，如果一个 channel 只允许写，即使写进去了，也没有丝毫意义，因为没有机会读取里面的数据。所谓的单向 channel 概念，其实只是对 channel 的一种使用限制。

单项通道声明格式如下：

> var 通道实例 chan<- 元素类型   // 只能发送通道

> var 通道实例 <-chan 元素类型   // 只能接收通道

下面给出单项通道的使用例子：

```go
	sendOnlyChan := make(chan<- int) // 只能发送通道
	recOnlyChan := make(<-chan int) //只能接收通道
	sendOnlyChan <- 1
	<-sendOnlyChan
```

这个程序代码段，运行起来是报错的，这是非法的，程序将无法通过编译，程序会报错为：`invalid operation: <-sendOnlyChan (receive from send-only type chan<- int)`，但是如果一个通道只能读或者写，创建一个只写通道有什么用呢？**这就是信道转型的用途。可以将双向信道转换为只写或只读信道，但是反过来却不行。**，效果如下例子：

```go
package main

import "fmt"

func sendData(sendch chan<- int) {  
    sendch <- 10
}

func main() {  
    chnl := make(chan int)
    go sendData(chnl)
    fmt.Println(<-chnl)
}
```

#### 关闭通道

关闭 channel 非常简单，直接使用 Go语言内置的 close() 函数即可：

> close(ch)

在介绍了如何关闭 channel 之后，我们就多了一个问题：如何判断一个 channel 是否已经被关闭？我们可以在读取的时候使用多重返回值的方式：

> x, ok := <-ch

这个用法与 map 中的按键获取 value 的过程比较类似，只需要看第二个 bool 返回值即可，如果返回值是 false 则表示 ch 已经被关闭。

